<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
    }

    canvas {
      width: 100vw;
      height: 100vh;
    }
  </style>
</head>

<body>
  <canvas id="webgl"></canvas>
  <script src="./webgl.js"></script>
  <script src="./lib/matrix.js"></script>
  <script>
    const canvas = document.getElementById('webgl');
    const w = canvas.width;
    const h = canvas.height;
    let angle = 30.0;
    let mx;
    let mvpMatrix;

    let ANGLE_STEP = 30.0;
    let g_last = Date.now();

    resizeCanvas(canvas);
    const gl = canvas.getContext('webgl');

    // 顶点着色器
    const vertexShaderSource = `
    precision mediump float;
    attribute vec4 a_Position;
    attribute vec4 a_Color;
    attribute vec4 a_Normal;

    uniform vec3 u_LightColor;
    uniform vec3 u_LightDirection;
    uniform vec3 u_AmbientLight;

    uniform mat4 u_MvpMatrix;

    varying vec4 v_Color;

    void main() {
      gl_Position = u_MvpMatrix * a_Position;
      // 漫反射光照
      vec3 normal = normalize(a_Normal.xyz);
      float nDotL = max(dot(u_LightDirection, normal), 0.0);
      vec3 diffuse = u_LightColor * a_Color.rgb * nDotL;
      vec3 ambient = u_AmbientLight * a_Color.rgb;
      v_Color = vec4(diffuse + ambient, a_Color.a);
    }
  `;

    // 片元着色器
    const fragmentShaderSource = `
    precision mediump float;
    varying vec4 v_Color;
    void main() {
      gl_FragColor = v_Color;
    }
  `;

    webglInit(gl, vertexShaderSource, fragmentShaderSource);
    initBuffers(gl, gl.program);

    function initBuffers(gl, program) {
      // 八个点
      var verticesColors = new Float32Array([   // Coordinates
      // 1.0, 1.0, 1.0,  -1.0, 1.0, 1.0,  -1.0,-1.0, 1.0,   1.0,-1.0, 1.0, // v0-v1-v2-v3 front
      // 1.0, 1.0, 1.0,   1.0,-1.0, 1.0,   1.0,-1.0,-1.0,   1.0, 1.0,-1.0, // v0-v3-v4-v5 right
      // 1.0, 1.0, 1.0,   1.0, 1.0,-1.0,  -1.0, 1.0,-1.0,  -1.0, 1.0, 1.0, // v0-v5-v6-v1 up
      // -1.0, 1.0, 1.0,  -1.0, 1.0,-1.0,  -1.0,-1.0,-1.0,  -1.0,-1.0, 1.0, // v1-v6-v7-v2 left
      // -1.0,-1.0,-1.0,   1.0,-1.0,-1.0,   1.0,-1.0, 1.0,  -1.0,-1.0, 1.0, // v7-v4-v3-v2 down
      // 1.0,-1.0,-1.0,  -1.0,-1.0,-1.0,  -1.0, 1.0,-1.0,   1.0, 1.0,-1.0  // v4-v7-v6-v5 back
        0.5, 0.5, 0.5,
        -0.5, 0.5, 0.5,
        -0.5, -0.5, 0.5,
        0.5, -0.5, 0.5,

        0.5, 0.5, 0.5,
        0.5, -0.5, 0.5,
        0.5, -0.5, -0.5,
        0.5, 0.5, -0.5,

        0.5, 0.5, 0.5,
        0.5, 0.5, -0.5,
        -0.5, 0.5, -0.5,
        -0.5, 0.5, 0.5,


        -0.5, 0.5, 0.5,
        -0.5, 0.5, -0.5,
        -0.5, -0.5, -0.5,
        -0.5, -0.5, 0.5,

        -0.5, -0.5, -0.5,
        0.5, -0.5, -0.5,
        0.5, -0.5, 0.5,
        -0.5, -0.5, 0.5,

        0.5, -0.5, -0.5,
        -0.5, -0.5, -0.5,
        -0.5, 0.5, -0.5,
        0.5, 0.5, -0.5,
      ]);

      var colors = new Float32Array([    // Colors
        1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,     // v0-v1-v2-v3 front
        1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,     // v0-v3-v4-v5 right
        1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,     // v0-v5-v6-v1 up
        1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,     // v1-v6-v7-v2 left
        1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0,     // v7-v4-v3-v2 down
        1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0　    // v4-v7-v6-v5 back
      ]);

      var normals = new Float32Array([    // Normal
        0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0,  // v0-v1-v2-v3 front
        1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0,  // v0-v3-v4-v5 right
        0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 0.0,  // v0-v5-v6-v1 up
        -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0,  // v1-v6-v7-v2 left
        0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0,  // v7-v4-v3-v2 down
        0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0, 0.0, 0.0, -1.0   // v4-v7-v6-v5 back
      ]);

      var indices = new Uint8Array([
        0, 1, 2, 0, 2, 3,    // front
        4, 5, 6, 4, 6, 7,    // right
        8, 9, 10, 8, 10, 11,    // up
        12, 13, 14, 12, 14, 15,    // left
        16, 17, 18, 16, 18, 19,    // down
        20, 21, 22, 20, 22, 23     // back
      ]);

      // 求投影矩阵
      mvpMatrix = gl.getUniformLocation(program, 'u_MvpMatrix');
      mx = new Matrix4();
      mx.setPerspective(30,  canvas.width / canvas.height, 1, 100);
      mx.lookAt(3, 3, 7, 0, 0, 0, 0, 1, 0);
      gl.uniformMatrix4fv(mvpMatrix, false, mx.elements);

      // 将缓冲区顶点坐标数据分配给 a_Position
      const a_Position = gl.getAttribLocation(program, 'a_Position');
      const a_Color = gl.getAttribLocation(program, 'a_Color');
      const u_LightColor = gl.getUniformLocation(program, 'u_LightColor');
      const u_LightDirection = gl.getUniformLocation(program, 'u_LightDirection');
      const u_AmbientLight = gl.getUniformLocation(program, 'u_AmbientLight');

      const lightDirection = new Vector3([0.5, 3.0, 4.0]);
      lightDirection.normalize();

      gl.uniform3f(u_LightColor, 1.0, 1.0, 1.0);
      gl.uniform3f(u_AmbientLight, 1.0, 1.0, 1.0);
      gl.uniform3fv(u_LightDirection, lightDirection.elements);

      // 创建缓冲区
      const vertexColorBuffer = gl.createBuffer();
      const indexBuffer = gl.createBuffer();
      const colorBuffer = gl.createBuffer();
      /**
       * 1、创建缓冲区 gl.createBuffer()
       * 2、绑定缓冲区 gl.bindBuffer(gl.ARRAY_BUFFER, buffer)
       * 3、向缓冲区写入数据 gl.bufferData(gl.ARRAY_BUFFER, data, gl.STATIC_DRAW)
       * 4、分配缓冲区给属性变量 gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 3, 0)
       * 5、开启缓冲区 gl.enableVertexAttribArray(a_Position)
       */

      const FSIZE = verticesColors.BYTES_PER_ELEMENT;
      const C_FSIZE = colors.BYTES_PER_ELEMENT;

      // 第一个 数据缓冲区
      gl.bindBuffer(gl.ARRAY_BUFFER, vertexColorBuffer);
      // 向缓冲区写入数据
      gl.bufferData(gl.ARRAY_BUFFER, verticesColors, gl.STATIC_DRAW);
      gl.vertexAttribPointer(a_Position, 3, gl.FLOAT, false, FSIZE * 3, 0);
      gl.enableVertexAttribArray(a_Position);

      // 第二个 index
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
      gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, indices, gl.STATIC_DRAW);

      // 颜色值
      gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, colors, gl.STATIC_DRAW);
      gl.vertexAttribPointer(a_Color, 3, gl.FLOAT, false, C_FSIZE * 3, 0);
      gl.enableVertexAttribArray(a_Color);

      // 法向量
      const normalBuffer = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, normalBuffer);
      gl.bufferData(gl.ARRAY_BUFFER, normals, gl.STATIC_DRAW);
      const a_Normal = gl.getAttribLocation(program, 'a_Normal');
      gl.vertexAttribPointer(a_Normal, 3, gl.FLOAT, false, FSIZE * 3, 0);
      gl.enableVertexAttribArray(a_Normal);

      gl.enable(gl.CULL_FACE);
      render(gl, indices.length);
    }

    //设置canvas的大小
    function resizeCanvas(canvas, width, height) {
      if (canvas.width !== width) {
        canvas.width = width ? width : window.innerWidth;
      }
      if (canvas.height !== height) {
        canvas.height = height ? height : window.innerHeight;
      }
    }

    function render(gl, n) {
      const currentAngle = animate(angle);

      mx.setRotate(currentAngle, 0, 1, 0);
      gl.uniformMatrix4fv(mvpMatrix, false, mx.elements);

      gl.clearColor(0, 0, 0, 1);
      gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
      // 绘制立方体
      gl.drawElements(gl.TRIANGLES, n, gl.UNSIGNED_BYTE, 0);
      requestAnimationFrame(() => render(gl, n));
    }


    function animate(angle) {
      var now = Date.now();
      var elapsed = now - g_last;
      g_last = now;
      // Update the current rotation angle (adjusted by the elapsed time)
      var newAngle = angle + (ANGLE_STEP * elapsed) / 1000.0;
      return newAngle %= 360;
    }

    function translate(gl, program) {
      // 旋转60度
      const rad = angle * Math.PI / 90;
      const cos = Math.cos(rad);
      const sin = Math.sin(rad);

      const mx = gl.getUniformLocation(program, 'mx');
      const mxArr = new Float32Array([
        1, 0, 0, 0,
        0, cos, -sin, 0,
        0, sin, cos, 0,
        0, 0, 0, 1
      ]);
      gl.uniformMatrix4fv(mx, false, mxArr);

      const my = gl.getUniformLocation(program, 'my');
      const myArr = new Float32Array([
        cos, 0, -sin, 0,
        0, 1, 0, 0,
        sin, 0, cos, 0,
        0, 0, 0, 1
      ]);
      gl.uniformMatrix4fv(my, false, myArr);
    }

  </script>
</body>

</html>