<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>流光 Shader</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
    }

    #info {
      color: white;
      display: block;
      font-family: "Press Start 2P";
      font-size: 5vh;
      position: absolute;
      text-align: center;
      text-shadow: 2px 2px #1f1f1f;
      top: 5vh;
      width: 100%;
      z-index: 100;
    }
  </style>
</head>

<body>
</body>
<script type="importmap">
  {
    "imports": {
      "three": "../../build/three.module.js",
      "three/addons/": "../../examples/jsm/"
    }
  }
</script>
<script type="module">
  import * as THREE from 'three';
  import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
  import PathPointList from './utils.js';

  const { innerWidth, innerHeight } = window;
  const aspect = innerWidth / innerHeight;

  let renderer, camera, scene, controls, elapsedTime, lineMaterial, clock;

  function init() {
    renderer = new THREE.WebGLRenderer({
      antialias: true,
      logarithmicDepthBuffer: true,
    });

    renderer.setPixelRatio(window.devicePixelRatio);
    renderer.setSize(innerWidth, innerHeight);
    renderer.setAnimationLoop(animate.bind());

    document.body.appendChild(renderer.domElement);

    camera = new THREE.PerspectiveCamera(60, aspect, 0.01, 10000);
    camera.position.set(5, 5, 5);

    scene = new THREE.Scene();
    controls = new OrbitControls(camera, renderer.domElement);

    elapsedTime = { value: 0 };

    const grid = new THREE.GridHelper(10);
    scene.add(grid);

    const light = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(light);
    createPanel();
  }

  function createPanel() {
    const geometry = new THREE.PlaneGeometry(10, 10, 10);
    const material = new THREE.ShaderMaterial({
      uniforms: {
        uTime: elapsedTime,
      },
      vertexShader: `
        varying vec2 vUv;
        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
        }
      `,
      fragmentShader: `
        varying vec2 vUv;
        void main() {
          gl_FragColor = vec4(0.5, 0.4, 0.6, 1.0);
        }
      `,
    });
    const panel = new THREE.Mesh(geometry, material);
    panel.rotation.x = -Math.PI / 2;
    scene.add(panel);

    const pathPointList = new PathPointList();
    const points = [
      { x: -5, y: 5, z: 0, },
      { x: 0, y: 5, z: 0, },
      { x: 5, y: 5, z: 0, },
      { x: 5, y: 0, z: 0, },
      { x: 5, y: -5, z: 0, },
      { x: 0, y: -5, z: 0, },
      { x: -5, y: -5, z: 0, },
      { x: -5, y: 0, z: 0, },
    ];
    const up = new THREE.Vector3(0, 1, 0);
    pathPointList.set(points, 0.5, 10, up, false);
    const geometry1 = new THREE.BufferGeometry();
    console.log(pathPointList)
    geometry1.setAttribute('position', new THREE.BufferAttribute(vertices, 2));
    lineMaterial = new THREE.ShaderMaterial({
      uniforms: {
        uTime: { value: 0 },
      },
      vertexShader: `
        uniform float uTime;
        varying vec2 vUv;
        void main(){
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `,
      fragmentShader: `
        uniform float uTime;
        varying vec2 vUv;

        vec3 palette(float t) {
          vec3 a = vec3(0.5, 0.5, 0.5);
          vec3 b = vec3(0.5, 0.5, 0.5);
          vec3 c = vec3(1.0, 1.0, 1.0);
          vec3 d = vec3(0.263, 0.416, 0.557);
          return a + b*cos(6.28318*(c*t+d));
        }

        vec4 getColor(float l1, float l2, float l3, vec2 uv) {
          float s1 = abs(l1 - uv.x);
          if(s1 < 0.05) {
            return vec4(0.5,.5 - 5.0 * s1 ,.7,1.0);
          }
          if(s1 > 0.95) {
            return vec4(0.5, .5 - 5.0 * (1.0-s1), .7, 1.0);
          }

          float s2 = abs(l2 - uv.x);
          if(s2 < 0.05){
            return vec4(0.5,.5 - 5.0 * s2,.7,1.0);
          }
          if(s2>0.95){
            return vec4(0.5,.5 - 5.0 * (1.0-s2),.7,1.0);
          }
          float s3 =abs(l3 - uv.x) ;
          if(s3 < 0.05){
            return vec4(0.5,.5 - 5.0 *s3,0.7,1.0);
          }
          if(s2>0.95){
            return vec4(0.5,.5 - 5.0 *(1.0-s3),0.7,1.0);
          }
        }
        void main() {
          float l1 = fract(uTime);
          float l2 = fract(l1 + 0.33);
          float l3 = fract(l2 + 0.33);
          gl_FragColor = getColor(l1,l2,l3, vUv);
        }
      `,
      transparent: true,
      side: THREE.DoubleSide
    });

    const line = new THREE.LineLoop(geometry1, lineMaterial);
    line.rotation.x = -Math.PI / 2;
    line.position.y += 0.1;
    scene.add(line);
  }

  clock = new THREE.Clock();

  function animate() {
    const delta = clock.getDelta();
    elapsedTime.value = clock.getElapsedTime();
    controls.update();
    renderer.render(scene, camera);
    lineMaterial.uniforms.uTime.value += delta / 6;
  }

  init();

</script>

</html>