<!DOCTYPE html>
<html>

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <title>three.js css2d - label</title>
  <style>
    #webgl {
      background-color: #FFF;
    }
    body {
      margin: 0;
      overflow: hidden;
    }
  </style>
</head>

<body>
  <div id="webgl"></div>
</body>
<script type="importmap">
  {
    "imports": {
      "three": "../build/three.module.js",
      "three/addons/": "../examples/jsm/"
    }
  }
</script>
<script type="module">
import * as THREE from 'three';
import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
import { GUI } from 'three/addons/libs/lil-gui.module.min.js';

let scene, cube, camera, ambient, light, renderer, gui, plane, model;

const obj = {
  height: 1260,
  width: 1600,
};

const params = {
  x: 100,
  y: 100,
  z: 100,
  color: 0x00ff00,
};

function init() {
  // 创建一个三维场景
  scene = new THREE.Scene();
  // 创建一个透视相机
  camera = new THREE.PerspectiveCamera(45, obj.width / obj.height, 0.1, 1000);
  // 相机位置
  camera.position.set(0, 200, 0);
  // 相机观察目标
  camera.lookAt(0, 0, 0);

  // 材料
  const material = new THREE.MeshBasicMaterial({ color: 0x00afff });
  const pm = new THREE.MeshBasicMaterial({ color: 0xfaa0a0, side: THREE.DoubleSide});

  cube = new THREE.Mesh(new THREE.SphereGeometry(10), material);
  cube.position.set(-20, 0, 40);

  const plane = new THREE.Mesh(new THREE.PlaneGeometry(1000, 1000), pm);

  plane.rotation.x = -Math.PI / 2;
  // plane.position.y = -10;

  const group = new THREE.Group();
  group.add(cube);
  group.add(plane);
  scene.add(group);

  initLight();
  initRenderer();
  // initMath();
}

function initMath() {
  const quaternion = new THREE.Quaternion();
  // quaternion.setFromAxisAngle(new THREE.Vector3(0, 1, 0), Math.PI / 4);
  // cube.quaternion.multiply(quaternion);
  console.log(quatern ion);
  // cube.rotation.y = Math.PI / 4;
  // cube.rotation.z = Math.PI / 4;
  // cube.rotation.x = Math.PI / 4;
  // // const a = new THREE.Vector3(0, 0, -1);
  // // const b = cube.position.clone().sub(model.position)
  // // const d3 = a.dot(b);
  // // console.log(d3);

  // const a = new THREE.Vector3(50, 0, 0);
  // const b = new THREE.Vector3(30, 0, 30);

  // const O = new THREE.Vector3(0, 0, 0);
  // const arrowA = new THREE.ArrowHelper(a.clone().normalize(), O, a.length(),0xff0000);
  // // 绿色箭头表示向量b
  // const arrowB = new THREE.ArrowHelper(b.clone().normalize(), O, b.length(),0x00ff00);

  // const c = a.clone().cross(b);
  // const c1 = new THREE.Vector3();
  // c.crossVectors(a, b);
  // c1.crossVectors(b, a);

  // console.log(c, c1);

  // const arrowC = new THREE.ArrowHelper(c.clone().normalize(), O, c.length()/30,0x0000ff);
  // const arrowC1 = new THREE.ArrowHelper(c1.clone().normalize(), O, c1.length()/30,0x0000ff);

  // scene.add(arrowA, arrowB, arrowC, arrowC1);
}

function initLight() {
  // 坐标轴
  const axesHelper = new THREE.AxesHelper(200);
  scene.add(axesHelper);
  // 光源
  light = new THREE.DirectionalLight(0xffffff, 1);
  light.castShadow = true;
  light.decay = 0.0;
  light.position.set(100, 100, 100);
  // 渲染质量
  scene.add(light);

  const ambient = new THREE.AmbientLight(0xffffff, 0.5);
  scene.add(ambient);

  const loader = new GLTFLoader();
	loader.load('../examples/models/gltf/Xbot.glb', function(gltf) {
		model = gltf.scene;
    model.position.set(0, 0, 20);
    model.scale.set(14, 14, 14);
		scene.add(model);
    initMath();
  });
}

function initRenderer() {
  // 渲染器
  renderer = new THREE.WebGLRenderer({
    // antialias: true
  });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(obj.width, obj.height);
  renderer.render(scene, camera);
  document.getElementById("webgl").appendChild(renderer.domElement);

  const controls = new OrbitControls(camera, renderer.domElement);

  controls.addEventListener('change', () => {
    renderer.render(scene, camera);
  });
}

window.onresize = function() {
  render.setSize(window.innerWidth, window.innerHeight);
  camera.aspect = window.innerWidth / window.innerHeight;
  // 更新相机投影矩阵
  camera.updateProjectionMatrix();
}

function initGUI() {
  // GUI调试
  gui = new GUI();
  gui.open();
}

function createTexture() {
  return texture;
}

let y = 0;
function render() {
  // cube.rotateY(0.01);
  // 周期性执行渲染
  renderer.render(scene, camera);
  requestAnimationFrame(render);
}
init();
render();
// initGUI();
</script>
</html>
